# WFMS Zigbee Application – Module Structure Guide

This document explains the module-based structure of the Zigbee application. Each major function is separated into a **module** implemented as a pair of **header files** (`.h`) and **source files** (`.c`). The goal is to improve maintainability, make debugging easier, and prevent `app.c` from becoming a large “god file”.

---

## 1. System overview

### 1.1 High-level logic flow

```mermaid
flowchart TD
  A[Boot / Init] --> B[Zigbee RX (Telemetry)]
  B --> C[telemetry_rx.c parses ZCL]
  C --> D[app_state.c updates state]
  D --> E[app_log.c emits @DATA/@INFO (UART)]
  F[PC/Dashboard] -->|@CMD JSON| G[uart_link.c reads line]
  G --> H[cmd_handler.c parses + routes]
  H --> I[valve_ctrl.c / net_mgr.c]
  I --> J[app_log.c emits @ACK/@LOG]
  I --> K[Zigbee TX (On/Off, Network ops)]
  K --> D
```

### 1.2 Main data paths

- **Telemetry path:** Zigbee packet → `telemetry_rx.c` → `app_state.c` → `app_log.c` → UART output (`@DATA`)
- **Command path:** PC sends `@CMD {...}` → `uart_link.c` → `cmd_handler.c` → (`valve_ctrl.c` / `net_mgr.c`) → `app_log.c` (`@ACK/@LOG`)

---

## 2. Module-by-module responsibilities

### 2.1 `app.c`

**Entry module** for the Zigbee application.

- Hosts application callbacks such as `emberAfMainInitCallback()`, periodic ticks, and event handlers.
- Initializes the other modules, sets initial configuration, and optionally starts network formation/steering.

**Trade-off:** Clean and readable when used as an orchestrator. Be careful not to put all business logic here (avoid “god file”).

---

### 2.2 `app_config.h`

**Compile-time configuration** for app-defined parameters (endpoint, coordinator node ID, tick period, feature flags, etc.).

- Keep only app-owned macros here.
- Avoid redefining Zigbee/ZCL constants that are generated by ZAP in `autogen/zap-*.h`, because redefinitions commonly lead to compile errors.

**Best practice:** define only custom macros or use guarded fallbacks (`#ifndef ... #define ... #endif`) when absolutely needed.

---

### 2.3 `app_log.h` / `app_log.c`

**Logging + UART protocol output** for lines such as `@DATA`, `@INFO`, `@ACK`, `@LOG`.

- `printInfoToPC()` typically prints node/network identity (nodeId, EUI64, PAN ID, channel, uptime…).
- Provide high-level APIs (`appLogInfo`, `appLogData`, `appLogAck`, `appLogLog`) so other modules do not depend on formatting details.

**Trade-off:**
- ✅ Consistent output format and easier debugging
- ❌ Excessive logging may spam UART and consume CPU

---

### 2.4 `app_state.h` / `app_state.c`

**Single source of truth** for system state, e.g.: flow, valve state, battery, join status, last seen, etc.

- Updated by `telemetry_rx.c`
- Read by `app_log.c` when emitting `@DATA`
- Modified by `cmd_handler.c` / `valve_ctrl.c` when user commands change system state

**Trade-off:**
- ✅ Centralized visibility and easier debugging
- ❌ Requires clear ownership rules (who can write which fields) to prevent inconsistent updates

---

### 2.5 `app_utils.h` / `app_utils.c`

**Shared helpers**: string parsing, clamp utilities, EUI64 → hex conversion, safe buffer helpers, random helpers, etc.

**Trade-off:** Very convenient, but avoid turning it into a “misc dump” of unrelated logic.

---

### 2.6 `app_zcl_fallback.h`

**Fallback ZCL IDs/constants** used only when autogen headers are missing or configuration mismatches occur.

- In standard Zigbee projects, `autogen/zap-id.h` should already define most ZCL constants.
- This file is a common source of macro redefinition errors.

**Guideline:** Prefer autogen headers; use fallback only if you truly need portability across builds.

---

### 2.7 `buttons.c`

**Button handling (PB0/PB1)** for local actions such as reset/join, feature toggles, or UART gateway toggling.

- Typically uses callbacks like `sl_button_on_change()`.
- Data flow: button event → call `net_mgr` or update `app_state` → log via `app_log`.

---

### 2.8 `cmd_handler.h` / `cmd_handler.c`

**UART command parser** for PC/Dashboard control.

- Accepts lines like `@CMD {...}` and parses JSON.
- Routes operations by `"op"`, for example:
  - `"valve_set"` → `valve_ctrl`
  - `"net_form"` / `"net_cfg_set"` → `net_mgr`
- Returns results via `@ACK`.

**Trade-off:**
- ✅ Clear boundary between protocol layer and business logic
- ❌ JSON parsing on MCU must be careful about memory, bounds, and malformed input

---

### 2.9 `net_mgr.h` / `net_mgr.c`

**Network management**: form/join/leave/steering/channel/panId/tx power…

- Wraps Zigbee stack APIs for network creation and steering.

**Forward-looking note:** Features like auto-rejoin, factory reset, or leave+join-on-reset belong here.

---

### 2.10 `telemetry_rx.c`

**Telemetry receive path** from other Zigbee nodes (often via `emberAfPreCommandReceivedCallback`).

- Parses `clusterId`, `commandId`, and payload.
- Updates `app_state` (flow/battery/valve…).
- Optionally triggers `appLogData()` for realtime updates to the PC.

**Trade-off:** Efficient, but must strictly follow ZCL frame formats and endpoint matching.

---

### 2.11 `uart_link.h` / `uart_link.c`

**UART transport layer**: reads raw bytes, assembles lines, detects `@CMD`, and forwards to `cmd_handler.c`.

- Often includes line buffers, ring buffers, and timeout handling.

**Trade-off:**
- ✅ Clean separation between raw I/O and JSON/business parsing
- ❌ Risk of buffer overflow if max line length is not enforced

---

### 2.12 `valve_ctrl.h` / `valve_ctrl.c`

**Valve control logic** + Zigbee On/Off client/server behavior (depending on node role).

- Sends On/Off commands to a valve node or handles incoming control.
- May contain callbacks like `emberAfTrustCenterJoinCallback()` to log/report join events.

**Trade-off:**
- ✅ Keeps valve-related logic in one place
- ❌ Can become a “god module” if network + telemetry + UART logic are mixed inside

---

## 3. Generated code (`autogen/`)

The `autogen/` directory contains code generated by Simplicity Studio / AppBuilder / ZAP:

- `zap-id.h`, `zap-type.h`
- command parsing and callback dispatch stubs
- cluster/attribute/command IDs and types

**Rules:**
- Do **not** edit autogen files directly (regeneration will overwrite changes).
- Treat autogen headers as the **source of truth** for ZCL constants.

---

## 4. Practical debugging tips

- **`implicit declaration`** errors usually mean: missing header include, or the function is not declared in its header.
- **macro redefinition** errors (especially ZCL_*): usually caused by redefining constants already defined by `af.h` or `autogen/zap-*.h`.
- If UART output feels “spammy”, throttle `@DATA` emission (e.g., only log when values change or on a fixed interval).

---
